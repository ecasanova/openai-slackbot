import { EventEmitter } from 'eventemitter3';
import WebSocket from 'ws';
import { AppsConnectionsOpenResponse } from '@slack/web-api';
import { SocketModeOptions } from './SocketModeOptions';
/**
 * An Socket Mode Client allows programs to communicate with the
 * [Slack Platform's Events API](https://api.slack.com/events-api) over WebSocket connections.
 * This object uses the EventEmitter pattern to dispatch incoming events
 * and has a built in send method to acknowledge incoming events over the WebSocket connection.
 */
export declare class SocketModeClient extends EventEmitter {
    /**
     * Whether or not the client is currently connected to the web socket
     */
    connected: boolean;
    /**
     * Whether or not the client has authenticated to the Socket Mode API.
     * This occurs when the connect method completes,
     * and a WebSocket URL is available for the client's connection.
     */
    authenticated: boolean;
    /**
     * Returns true if the underlying WebSocket connection is active.
     */
    isActive(): boolean;
    /**
     * The underlying WebSocket client instance
     */
    websocket?: WebSocket;
    constructor({ logger, logLevel, autoReconnectEnabled, pingPongLoggingEnabled, clientPingTimeout, serverPingTimeout, appToken, clientOptions, }?: SocketModeOptions);
    /**
     * Start a Socket Mode session app.
     * It may take a few milliseconds before being connected.
     * This method must be called before any messages can be sent or received.
     */
    start(): Promise<AppsConnectionsOpenResponse>;
    /**
     * End a Socket Mode session. After this method is called no messages will be sent or received
     * unless you call start() again later.
     */
    disconnect(): Promise<void>;
    /**
     * State machine that backs the transition and action behavior
     */
    private stateMachine;
    /**
     * Internal count for managing the reconnection state
     */
    private numOfConsecutiveReconnectionFailures;
    private connectingStateMachineConfig;
    private connectedStateMachineConfig;
    /**
     * Configuration for the state machine
     */
    private stateMachineConfig;
    /**
     * Whether this client will automatically reconnect when (not manually) disconnected
     */
    private autoReconnectEnabled;
    private secondaryWebsocket?;
    private webClient;
    /**
     * The name used to prefix all logging generated from this object
     */
    private static loggerName;
    /**
     * This object's logger instance
     */
    private logger;
    /**
     * Enables ping-pong detailed logging if true
     */
    private pingPongLoggingEnabled;
    /**
     * How long to wait for pings from server before timing out
     */
    private serverPingTimeoutMillis;
    /**
     * Reference to the timeout timer we use to listen to pings from the server
     */
    private serverPingTimeout;
    /**
     * How long to wait for pings from server before timing out
    */
    private clientPingTimeoutMillis;
    /**
     * Reference to the timeout timer we use to listen to pongs from the server
     */
    private clientPingTimeout;
    /**
     * The last timetamp that this WebSocket client received pong from the server
     */
    private lastPongReceivedTimestamp;
    /**
     * Used to see if a WebSocket stops sending heartbeats and is deemed bad
     */
    private badConnection;
    /**
     * This flag can be true when this client is switching to a new connection.
     */
    private isSwitchingConnection;
    /**
     * WebClient options we pass to our WebClient instance
     * We also reuse agent and tls for our WebSocket connection
     */
    private clientOptions;
    /**
     * Method for sending an outgoing message of an arbitrary type over the WebSocket connection.
     * Primarily used to send acknowledgements back to slack for incoming events
     * @param id the envelope id
     * @param body the message body or string text
     */
    private send;
    private retrieveWSSURL;
    private autoReconnectCondition;
    private reconnectingCondition;
    private configureAuthenticatedWebSocket;
    private handleConnectionFailure;
    private markCurrentWebSocketAsInactive;
    /**
     * Clean up all the remaining connections.
     */
    private terminateAllConnections;
    /**
     * Set up method for the client's WebSocket instance. This method will attach event listeners.
     */
    private setupWebSocket;
    /**
     * Tear down the currently working heartbeat jobs.
     */
    private terminateActiveHeartBeatJobs;
    /**
     * Switch the active connection to the secondary if exists.
     */
    private switchWebSocketConnection;
    /**
     * Tear down method for the client's WebSocket instance.
     * This method undoes the work in setupWebSocket(url).
     */
    private terminateWebSocketSafely;
    private startPeriodicallySendingPingToSlack;
    private handlePingPongErrorReconnection;
    /**
     * Confirms WebSocket connection is still active
     * fires whenever a ping event is received
     */
    private startMonitoringPingFromSlack;
    private isConnectionReady;
    /**
     * `onmessage` handler for the client's WebSocket.
     * This will parse the payload and dispatch the relevant events for each incoming message.
     */
    protected onWebSocketMessage({ data }: {
        data: string;
    }): Promise<void>;
}
export default SocketModeClient;
//# sourceMappingURL=SocketModeClient.d.ts.map